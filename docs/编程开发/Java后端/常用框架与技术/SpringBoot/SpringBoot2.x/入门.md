# 入门

---

参考：

```wiki
1. 尚硅谷官方学习笔记。
2. SpringBoot官方文档：https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/
```



## 总览

- 相较于 **SpringBoot1.x** ， **SpringBoot2.x** 的配置和底层源码有了很大不同，同时 **SpringBoot2.x** 引入了 **响应式编程** 。
- SpringBoot 是整合 Spring 技术栈的一站式框架。
- SpringBoot 是简化 Spring 技术栈的快速开发脚手架。



##  POM文件

### 父项目

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐starter‐parent</artifactId>
    <version>2.3.4.RELEASE</version>
</parent>
```

我们在 pom 文件引用了 `spring‐boot‐starter‐parent` ，它的父项目是 `spring‐boot‐dependencies` 。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring‐boot‐dependencies</artifactId>
    <version>2.3.4.RELEASE</version>
    <relativePath>../../spring‐boot‐dependencies</relativePath>
</parent>
```

- `spring‐boot‐dependencies` 用于管理 Spring Boot 应用里面的所有 **依赖版本** ，是 Spring Boot的 **版本仲裁中心** ；
- 以后我们导入依赖默认是不需要写版本（没有在 dependencies 标签里面管理的依赖自然需要声明版本号）。

### 修改依赖版本

如果我们需要引入 `spring‐boot‐dependencies` 已经管理的依赖的版本，则可以：

- 先在 `spring‐boot‐dependencies` 中找到对应依赖的版本变量；
- 然后在我们项目的 `pom` 文件中也定义这个变量，由于就近优先原则， 这个值将覆盖 `spring‐boot‐dependencies` 中的那个值；

如：

```xml
<properties>
    <mysql.version>8.0.21</mysql.version>
</properties>
```

### 启动器

如：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

- Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器）依赖，需要什么功能便引入什么 starter 。

- 官方包的命名方式: `spring-boot-starter-*` ；第三方包的命名方式: `*-spring-boot-starter` 。

- Spring Boot 所有支持的场景: https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter

- 所有场景启动器最底层的依赖:

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
      <version>2.3.4.RELEASE</version>
      <scope>compile</scope>
  </dependency>
  ```

## 主程序类

### SpringApplication.run()

`SpringApplication.run()` 方法会返回 bean 容器。

```java
ConfigurabelApplicationContext applicationContext = SpringApplication.run(MainApplication.class,args);
// 获取各个bean的名字
String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();
```

### 修改扫描的包

- **主程序所在包** 及其 **所有子包** 中的 **所有组件** 都会被默认扫描进来。

- 想要改变扫描路径，可以有以下两种配置：

  ```java
  @SpringBootApplication(scanBasePackages="com.atguigu")
  
  // 上下两个等价
  
  @SpringBootConfiguration
  @EnableAutoConfiguration
  @ComponentScan("com.atguigu")
  ```


### 自动配置

- `spring-boot-starter` 依赖 `spring-boot-autoconfigure` 。
-  `spring-boot-autoconfigure` 就是用于实现自动配置的。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-autoconfigure</artifactId>
    <version>2.3.4.RELEASE</version>
    <scope>compile</scope>
</dependency>
```

![image-20220313005219500](入门/image-20220313005219500.png)

- 类似 `BatchAutoConfiguration` 这种以 `*Configuration` 结尾的类，就是用于自动配合的类。
- 我们看到有爆红的地方，这是因为我们没有引入相关的启动器（没有引入相关的启动器就不会进行相应的自动配置）。

![image-20220313005307925](入门/image-20220313005307925.png)

## 底层注解

### @Conditional 相关注解

- 可以加在 **组件类（如@Component、@Configuration等）** 上，也可以加在 **带@Bean注解的方法** 上。
- 表明只有满足相应的条件是， `Bean` 才生效。

![image-20220313193152423](入门/image-20220313193152423.png)

```java
// 如
@ConditionalOnMissingBean(name = "tom")
public class MyConfig {
   // xxxx
}
```



### @ImportResource

- 用于导入原生的 Spring 配置文件。

```java
@ImportResource("classpath:beans.xml")
public class MyConfig {
   // xxxx
}
```



### @ConfigurationPropertiess

#### @ConfigurationPropertiess + @Component

- 使用如下两个注解即可将配置文件中前缀为 `mycar` 的配置项注入 `Car` 类中，创建 `Car` 的 bean 对象。

```java
@Component
@ConfigurationProperties(prefix = "mycar")
public class Car {
    // xxxx
}
```

```properties
mycar.brand=YD
mycar.price=100000
```

#### @ConfigurationPropertiess + @EnableConfigurationProperties

```java
@ConfigurationProperties(prefix = "mycar")
public class Car {
    // xxxx
}
```

`@EnableConfigurationProperties` 需要加在配置类上。

```java
@Configuration
@EnableConfigurationProperties(Car.class)
public class MyConfig {
}
```

## 自动配置原理入门

### @SpringBootApplication

`@SpringBootApplication` 的底层注解。

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
	@AliasFor(annotation = EnableAutoConfiguration.class)
	Class<?>[] exclude() default {};

	@AliasFor(annotation = EnableAutoConfiguration.class)
	String[] excludeName() default {};

	@AliasFor(annotation = ComponentScan.class, attribute = "basePackages")
	String[] scanBasePackages() default {};

	@AliasFor(annotation = ComponentScan.class, attribute = "basePackageClasses")
	Class<?>[] scanBasePackageClasses() default {};

	@AliasFor(annotation = ComponentScan.class, attribute = "nameGenerator")
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
```

#### @SpringBootConfiguration

`@SpringBootConfiguration` 的底层注解。

```java
@Configuration
public @interface SpringBootConfiguration {
    @AliasFor(annotation = Configuration.class)
    boolean proxyBeanMethods() default true;
}
```

与 `@Configuration` 功能一致，表明当前类是配置类。

#### @ComponentScan

指定扫描哪些包（是Spring原生注解）。

#### @EnableAutoConfiguration

`@EnableAutoConfiguration` 的底层注解。

```java
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
	String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

	Class<?>[] exclude() default {};

	String[] excludeName() default {};
}
```

##### @AutoConfigurationPackage

`@AutoConfigurationPackage` 的底层注解。

```java
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {
	String[] basePackages() default {};

	Class<?>[] basePackageClasses() default {};
}
```

`AutoConfigurationPackages.Registrar` 

```java
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
    }

    @Override
    public Set<Object> determineImports(AnnotationMetadata metadata) {
        return Collections.singleton(new PackageImports(metadata));
    }
}
```

- `AnnotationMetadata metadata` 表示 `@AutoConfigurationPackage` 注解的相关信息，获取到了主程序所在的包路径。
- 该注解的主要作用：指定了 SpringBoot 默认扫描的包。

##### @Import(AutoConfigurationImportSelector.class)

